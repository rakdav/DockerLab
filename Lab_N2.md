# Лабораторная работа №2
## Сборка и выполнение программ в Docker
---
### Сборка Docker образов

Образы Docker являются результатом процесса их сборки, а контейнеры — это выполняющиеся образы. В самом сердце Docker находятся файлы `Dockerfile`. Подобные файлы сообщают Docker о том, как собирать образы.

Каждому образу соответствует файл, который называется `Dockerfile`. В `Dockerfile` указываются последовательные инструкции, описывающие порядок сборки. Например: используем ubuntu -> создаем в ней директорию -> копируем в директорию наш созданный код -> добавляем команду заупска нашего кода.

Каждая команда - это слой. Чуть позже мы подробнее ознакомимся с этим понятием. На текущий момент подробнее проговорим о самых выжных командах используемых для сборки образов.

---
### Часто используемые команды для сборки образов

-   `FROM` — задаёт базовый (родительский) образ.
-   `ENV` — устанавливает постоянные переменные среды.
-   `RUN` — выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов.
-   `COPY` — копирует в контейнер файлы и папки.
-   `ADD` — копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы.
-   `CMD` — описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция CMD.
-   `WORKDIR` — задаёт рабочую директорию для следующей инструкции.
-   `ENTRYPOINT` — предоставляет команду с аргументами для вызова во время выполнения контейнера. Аргументы не переопределяются.

---
### Инструкция `FROM`

Файл `Dockerfile` должен начинаться с инструкции `FROM`.

Ключевое слово `FROM` сообщает Docker какой базовый образ необходимо использовать при сборке контейнера. Пример:

```Dockerfile
FROM ubuntu:18.04
```

В этом примере мы взяли базовый образ `ubuntu` версии `18.04`. Если поставить вместо версии значение `latest` или пустое значение:
```Dockerfile
FROM ubuntu
```
при сборке будет использоваться последняя имеющаяся версия `ubuntu`.
Существует много базовых образов с уже предустановленным ПО. Например, если для программы необходим `python`, для сборки образа можно использовать официальный образ с уже предустановленным `python`. Пример ([ссылка](https://hub.docker.com/_/python) на официальный образ):

```Dockerfile
FROM python:3
```
Базовых образов очень много. Они могут быть на основе разных операционных систем и могут содержвать в себе разые предустановленные программы. Например, если необходим образ с уже предустановленным ПО для запуска программ на языке `java`/`ruby`, пожалуйста. Для них уже имеется масса готовых базовых образов ([ruby](https://hub.docker.com/_/ruby), [java](https://hub.docker.com/_/openjdk)). Пример:
```Dockerfile
# используется образ с предустановленным по для ruby
# версия ruby - 2.5
FROM ruby:2.5
```
```Dockerfile
# используется образ с предустановленным по для java
# версия openjdk - 1.1
FROM openjdk:11
```

---
### Инструкция `RUN`

Инструкция `RUN` используется для запуска команды, которе добавит изменение в образе. Команда должна быть конечной, это важно, так как в ином случае сборка образа остановится с ошибкой. Где может использоваться данная команда. Чаще всего ее используют для скачивания дополнительных инструментов. В прошлой лабораторной работе мы использовали команду для скачивания дополнительных `python` библиотек:
```Dockerfile
RUN pip3 install -r requirements.txt
```
Сама команда `RUN` передает в аргументы то, что можно выполнить в консоли. Например:
```Dockerfile
FROM ubuntu

# Запуск команды ls для отображения списка файлов в директории
RUN ls

# Запуск команды для вывода содержимого файла в консоли
RUN cat file.txt

# Показать полное название текущей директории
RUN pwd

# Создание папки тест в корне образа
RUN mkdir /test

# Добавление прав на запуск файла
RUN chmod +x script.sh

# Скачивание дополнительных утилит
# Флаг -y необходим для автоматического подтверждения скачивания
# дополнительных пакетов
RUN apt-get update && apt-get install -y \
    python \
    curl \
    nano
```
Команды выполняются в оболочках выбранной нами системы (выбрали мы ее, при указании команды `FROM`). Это может быть `bash`, `sh` или любая другая стандартная оболочка, которая присутствует в образе (Аналогично прошлой лабораторной работе ПО bash может отсутствовать в используемом Вами дистрибутиве; это может быть объяснено различием набора предустановленного программного обеспечения для Debian, Ubuntu, CentOS и других ОС, несмотря на то, что все они являются Linux).

Необходимо запомнить, что указанная строчка записи, например `RUN ls` добавит информацию о запуске команды, что увеличит образ. Поэтому стоит выполнять только те команды, которые действительно необходимы.

Для примеров советую обратиться к [best practices](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#run) по использованию данной команды.

---
### Инструкции `COPY` и `ADD`

Инструкции `COPY` и `ADD` очень схожи. На самом деле, они выполняют практически одинаковые вещи, а именно, добавление файлов в образ из вне. Например, у вас имеется директория с проектом и вам необходимо добавить файлы проекта в образ.

Пример с `COPY`:

```Dockerfile
FROM ubuntu

# Копирование файла requirements.txt в папку /tmp/ внутри образа
# Файл requirements.txt должен находиться возле файла Dockerfile
COPY requirements.txt /tmp/

# Копирование всех файлов расположенных рядом с Dockerfile в папку /tmp/ внутри образа
COPY . /tmp/

# Копирование файлов с указанием пользователя и группы пользователей
# которым файл будет доступен внутри контейнера
COPY --chown=user:mygroup . /tmp/
```
Пример с `ADD`:

```Dockerfile
FROM ubuntu

# Копирование файла requirements.txt в папку /tmp/ внутри образа
# Файл requirements.txt должен находиться возле файла Dockerfile
ADD requirements.txt /tmp/

# Копирование всех файлов расположенных рядом с Dockerfile в папку /tmp/ внутри образа
ADD . /tmp/

# Копирование файлов с указанием пользователя и группы пользователей
# которым файл будет доступен внутри контейнера
ADD --chown=user:mygroup . /tmp/
```

В чем же отличие команды `ADD` от C`OPY`? Команда `ADD` имеет дополнителбный функционал, такой как скачивание файлов по ссылке и разархивация архивов. Пример:

```Dockerfile
FROM ubuntu

# Скачиваем файл в директорию /usr/src/things/
ADD https://example.com/big.tar.xz /usr/src/things/
# Распаковка архива
RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things
```

На самом деле, команду `ADD` практически никогда не используют из-за непрозрачного результата его работы. Вместо дополнительных встроенных команд `ADD` чаще всего используют команду `RUN`. Пример:
```Dockerfile
FROM ubuntu

# Тоже самое, но с использование команды RUN
RUN mkdir -p /usr/src/things \
    && curl -SL https://example.com/big.tar.xz \
    | tar -xJC /usr/src/things
```

Поэтому, советую использовать только команду `COPY`. Зачем мы изучили команду `ADD`? Если в дальнейшем вам встретится пример с использованием команды `ADD`, вы сможете легко понять что происходит в данном контексте, и для своего решения сможете заменить его на `COPY` и `RUN`. Для ознакомление, советую изучить для себя [best practices](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#add-or-copy) для работы с командами copy и add.

---
### Инструкция `WORKDIR`

Команда `WORKDIR` перемещает дальнейшее выполнение команд указанных ниже в каталог. Рассмотрим пример:
```Dockerfile
FROM ubuntu

WORKDIR /app
COPY ./ ./
```

Команда `WORKDIR /app` создаст директорию `/app` и переместит выполнение команды `COPY` (а также команды следующие после) в эту директорию. То есть все файлы скопируются в папку `/app`. Команда `WORKDIR` действует таким же образом на команды: `RUN`, `CMD`, `ENTRYPOINT`, `COPY` и `ADD`.

---
### Инструкция `ENV`

Инструкция `ENV` позволяет добавлять переменную среды. Например, в `Dockerfile` имеется повторение одного ресурса несколько раз. Чтобы не писать повторение, можно создать переменную и переиспользовать ее. Пример:

```Dockerfile
FROM ubuntu

ENV APP_DIR=app

WORKDIR /$APP_DIR
COPY ./ ./
```

В примере мы создали переменную `APP_DIR=app` и использовали ее при запуске команды `WORKDIR /$APP_DIR`. Также, через переменные мы можем зафиксировать значения по-умолчанию для запуска программы. Например:

```Dockerfile
FROM python:3


WORKDIR /app
COPY ./ ./main.py

ENV OTHER_APP_ADDR=192.168.1.1:8080
CMD ["python3", "./main.py", "$OTHER_APP_ADDR"]
```

Предположим, что у нас имеется приложение, которое подключается к другому приложению. И адрес передается через адргументы, при запуске программы. Для того, чтобы обозначить адрес программы, мы можем указать его внутри `Dockerfile` через переменную (и зафиксировать какое-нибудь значение по-умолчанию). Тогда, при запуске образа мы сможем переопределить данное значение:

```bash
docker run <название образа> --env OTHER_APP_ADDR=192.168.1.2:9090 
```

---
### Инструкция `CMD` и `ENTRYPOINT`

`ENTRYPOINT` - это точка входа. В каждом контейнера она должна присутствовать. Рассмотрим стандартный контейнер `ubuntu`. В предыдущей лабораторной работе, когда мы хотели зайти в нутрь запущенного контейнера, мы выполняли следующую команду:

```bash
docker run -it --rm ubuntu bash
```
При запуске контейнера мы передавали команду `bash`, которую хотели запустить. Но, на самом деле, если залезть под капот докера, полная команда будет выглядеть следующим образом:

```bash
/bin/sh -c bash
```
команда `bash` будет частью большой команды (будет являться аргументом). Тогда что такое `/bin/sh -c `? На самом деле, это и есть `ENTRYPOINT` (точкой входа). То есть, это команда, которая будет неким префиксом общей команды. При этом, сама команда `bash` - будет являться `CMD`.

Рассмотрим еще пример:
```bash
docker run --rm ubuntu ls /
```

Полная команда будет выглядеть так: `/bin/sh -c ls /`
- `/bin/sh -c` - `ENTRYPOINT`
- `ls /` - `CMD`

Мы не будем подробно останавливаться на `ENTRYPOINT`, но необходимо понимать для чего он используется.

`CMD` - это команда, выполняемая `ENTRYPOINT` (а точнее, это аргумент для `ENTRYPOINT`). На самом деле, все зависит от написания данной команды:
```Dockerfile
# Форма exec, это предпочтительная форма
CMD ["executable","param1","param2"]
# Как параметр по-умолчанию для ENTRYPOINT
CMD ["param1","param2"]
# Форма оболочки
# команда выполнится через /bin/sh -c
CMD command param1 param2
```

Пример записи может быть таким (форма оболочки):

```Dockerfile
FROM ubuntu
CMD echo "This is a test."
```
Или таким (форма exec):

```Dockerfile
CMD [ "python3", "-m" , "flask", "run", "--host=0.0.0.0", "--port=8080"]
```

Так как мы будем работать только с `CMD`, будет достаточно запомнить 2 верхних примера. Для более подробной информации по взаимодействия `ENTRYPOINT` с `CMD` советую подробно рассмотреть [данную таблицу](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact). В таблице расписано как будет выглядеть итоговая команда в разных сочетаниях.

Также, стоит отметить, что можно записать несколько команд в одном `Dockerfile`, но только последняя будет служить командой запуском контейнера (остальные команды будут проигнорированы).

---
### Задание

> Перед выполнением необходимо запустить следующие команды:
> ```bash
> # Остановка всех контейнеров
> docker kill $(docker ps -a -q)
> # Удаление всех контейнеров
> docker rm $(docker ps -a -q)
> # Удаление всех неиспользуемых сущностей (используемых в docker)
> docker system prune -a
> ```

-   Написать программу на python3, которая будет выводить в консоль текущее время (каждые 5 секунд).
    Создать образ с данной программой и запустить контейнер.
    В результате, вы сможете увидеть в логах контейнера текущее время.
    Дополнительно ввести проверку архитектуры аппаратного обеспечения, при использовании X86 - выводить сообщение об используемой архитектуре и время каждые 10 секунд, при x64 - каждые 7 секунд, при ARM - каждые 3 секунды.
    Дополнительно ввести в программу возможность вывода времени в виде временного штампа.

    Дополнительная информация:

    -   В Dockerfile указать следующее `CMD`:

        ```Dockerfile
        # Обязательно с флагом -u
        CMD [ "python3", "-u", "main.py"]
        ```
    -   Используемый образ: `python:3.8-slim-buster`
    -   Команда для запуска контейнера:
        ```bash
        # Флаг --rm автоматически удалит контейнер,
        # если тот остановится
        docker run -d --rm <название образа>
        ```
    -   команда для проверки логов:
        ```bash
        docker logs <id контейнера>
        # для получения id контецнера, используйте команду
        # docker ps -a
        ```


-   Добавить в ПО значение величины задержки отображения (не каждые 5 секунд, а, например, каждые 10 секунд)

    Дополнительная информация:
    -   Для передачи значения использовать `ENV` переменную с названием `TIME_SLEEP`;
    -   Для передачи значения переменной при запуске контейнера воспользоваться командой:
        ```bash
        docker run -d --rm --env TIME_SLEEP=10 <название образа>
        ```
